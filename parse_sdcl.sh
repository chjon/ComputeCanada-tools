#!/bin/bash

# Input validation
if [[ $# -ne 4 ]]; then
	echo "Usage: $0 <SOLVER_NAME> <INPUT_FILE> <START_INDEX> <NUM_LINES>"
	exit -1
fi

# Check that file exists
INPUT_FILE=$2
if [[ ! -f $INPUT_FILE ]]; then
	echo "File '${INPUT_FILE}' does not exist"
	exit -1
fi

# Get parameters
SOLVER_NAME=$1
START_INDEX=$3
END_INDEX=$((START_INDEX + $4 - 1))

# Global config
GLOBAL_SAT="SATISFIABLE"
GLOBAL_UNSAT="UNSATISFIABLE"
GLOBAL_INDET="INDETERMINATE"

# Parse maplesat log files
parse_maplesat() {
	PROBLEM=$1
	LOG_FILE=$2

	# Parse solver results
	RESTARTS=(`grep "restarts" ${LOG_FILE}`); RESTARTS=${RESTARTS[2]}
	CONFLICTS=(`grep "conflicts" ${LOG_FILE}`); CONFLICTS=${CONFLICTS[2]}
	DECISIONS=(`grep "decisions" ${LOG_FILE}`); DECISIONS=${DECISIONS[2]}
	PROPAGATIONS=(`grep "propagations" ${LOG_FILE}`); PROPAGATIONS=${PROPAGATIONS[2]}
	CONF_LITS=(`grep "conflict literals" ${LOG_FILE}`); CONF_LITS=${CONF_LITS[3]}
	EXT_VARS=0
	EXT_DECISIONS=0
	CONF_EXT_CLAUSES=0
	LEARNT_EXT_CLAUSES=0
	LEARNT_LBD=""

	MEM_USED=(`grep "Memory used" ${LOG_FILE}`); MEM_USED=${MEM_USED[3]}
	CPU_TIME=(`grep "CPU time" ${LOG_FILE}`); CPU_TIME=${CPU_TIME[3]}
    
	SDCL_LEARNTS=0
    SDCL_CHILDREN_SPAWNED=0
    SDCL_CHILDREN_KILLED=0
    SDCL_CHILDREN_RET_SAT=0
    SDCL_AVG_WIDTH=0
    SDCL_MIN_WIDTH=0
    CDCL_AVG_WIDTH=0
    SDCL_TOTAL_OVERHEAD=0
    SDCL_LTC_OVERHEAD=0
    SDCL_CPC_OVERHEAD=0
    SDCL_CCES_OVERHEAD=0

	SDCL_PP_OVERHEAD=0
	SDCL_SSEO_OVERHEAD=0
	SDCL_SSOO_OVERHEAD=0

	SATISFIABILITY=`tail -n 1 ${LOG_FILE}`

	# Normalize reported satisfiability values
	if [[ ${SATISFIABILITY} != ${GLOBAL_SAT} && ${SATISFIABILITY} != ${GLOBAL_UNSAT} ]]; then
		SATISFIABILITY=${GLOBAL_INDET}
	fi

	echo "${SOLVER_NAME},${PROBLEM},${RESTARTS},${CONFLICTS},${DECISIONS},${PROPAGATIONS},${CONF_LITS},${MEM_USED},${CPU_TIME},${SDCL_LEARNTS},${SDCL_CHILDREN_SPAWNED},${SDCL_AVG_WIDTH},${SDCL_TOTAL_OVERHEAD},${SDCL_LTC_OVERHEAD},${SDCL_CPC_OVERHEAD},${SDCL_CCES_OVERHEAD},${SDCL_PP_OVERHEAD},${SDCL_SSEO_OVERHEAD},${SDCL_SSOO_OVERHEAD},${SATISFIABILITY}"
}

# Parse xMaplesat log files
parse_xmaplesat() {
	PROBLEM=$1
	LOG_FILE=$2

	# Parse solver results
	RESTARTS=(`grep "restarts" ${LOG_FILE}`); RESTARTS=${RESTARTS[2]}
	CONFLICTS=(`grep "conflicts" ${LOG_FILE}`); CONFLICTS=${CONFLICTS[2]}
	DECISIONS=(`grep "decisions" ${LOG_FILE}`); DECISIONS=${DECISIONS[2]}
	PROPAGATIONS=(`grep "propagations" ${LOG_FILE}`); PROPAGATIONS=${PROPAGATIONS[2]}
	CONF_LITS=(`grep "conflict literals" ${LOG_FILE}`); CONF_LITS=${CONF_LITS[3]}
	EXT_VARS=(`grep "ext vars" ${LOG_FILE}`); EXT_VARS=${EXT_VARS[3]}
	EXT_DECISIONS=(`grep "decisions on ext vars" ${LOG_FILE}`); EXT_DECISIONS=${EXT_DECISIONS[5]}
	CONF_EXT_CLAUSES=(`grep "conflict ext clauses" ${LOG_FILE}`); CONF_EXT_CLAUSES=${CONF_EXT_CLAUSES[4]}
	LEARNT_EXT_CLAUSES=(`grep "learnt ext clauses" ${LOG_FILE}`); LEARNT_EXT_CLAUSES=${LEARNT_EXT_CLAUSES[4]}
	LEARNT_LBD=(`grep "total lbd of learnts" ${LOG_FILE}`); LEARNT_LBD=${LEARNT_LBD[5]}
	
	MEM_USED=(`grep "Memory used" ${LOG_FILE}`); MEM_USED=${MEM_USED[3]}
	CPU_TIME=(`grep "CPU time" ${LOG_FILE}`); CPU_TIME=${CPU_TIME[3]}

    SDCL_LEARNTS=0
    SDCL_CHILDREN_SPAWNED=0
    SDCL_CHILDREN_KILLED=0
    SDCL_CHILDREN_RET_SAT=0
    SDCL_AVG_WIDTH=0
    SDCL_MIN_WIDTH=0
    CDCL_AVG_WIDTH=0
    SDCL_TOTAL_OVERHEAD=0
    SDCL_LTC_OVERHEAD=0
    SDCL_CPC_OVERHEAD=0
    SDCL_CCES_OVERHEAD=0

	SDCL_PP_OVERHEAD=0
	SDCL_SSEO_OVERHEAD=0
	SDCL_SSOO_OVERHEAD=0

	SATISFIABILITY=`tail -n 1 ${LOG_FILE}`

	# Normalize reported satisfiability values
	if [[ ${SATISFIABILITY} != ${GLOBAL_SAT} && ${SATISFIABILITY} != ${GLOBAL_UNSAT} ]]; then
		SATISFIABILITY=${GLOBAL_INDET}
	fi

	echo "${SOLVER_NAME},${PROBLEM},${RESTARTS},${CONFLICTS},${DECISIONS},${PROPAGATIONS},${CONF_LITS},${MEM_USED},${CPU_TIME},${SDCL_LEARNTS},${SDCL_CHILDREN_SPAWNED},${SDCL_AVG_WIDTH},${SDCL_TOTAL_OVERHEAD},${SDCL_LTC_OVERHEAD},${SDCL_CPC_OVERHEAD},${SDCL_CCES_OVERHEAD},${SDCL_PP_OVERHEAD},${SDCL_SSEO_OVERHEAD},${SDCL_SSOO_OVERHEAD},${SATISFIABILITY}"
}

# Parse MapleLCM log files
parse_maplelcm() {	
	PROBLEM=$1
	LOG_FILE=$2

	# Parse solver results
	RESTARTS=(`grep "c restarts" ${LOG_FILE}`); RESTARTS=${RESTARTS[3]}
	CONFLICTS=(`grep "c conflicts" ${LOG_FILE}`); CONFLICTS=${CONFLICTS[3]}
	DECISIONS=(`grep "c decisions" ${LOG_FILE}`); DECISIONS=${DECISIONS[3]}
	PROPAGATIONS=(`grep "c propagations" ${LOG_FILE}`); PROPAGATIONS=${PROPAGATIONS[3]}
	CONF_LITS=(`grep "c conflict literals" ${LOG_FILE}`); CONF_LITS=${CONF_LITS[4]}
	EXT_VARS=0
	EXT_DECISIONS=0
	CONF_EXT_CLAUSES=0
	LEARNT_EXT_CLAUSES=0
	LEARNT_LBD=""

	MEM_USED=(`grep "c Memory used" ${LOG_FILE}`); MEM_USED=${MEM_USED[4]}
	CPU_TIME=(`grep "c CPU time" ${LOG_FILE}`); CPU_TIME=${CPU_TIME[4]}

    SDCL_LEARNTS=0
    SDCL_CHILDREN_SPAWNED=0
    SDCL_CHILDREN_KILLED=0
    SDCL_CHILDREN_RET_SAT=0
    SDCL_AVG_WIDTH=0
    SDCL_MIN_WIDTH=0
    CDCL_AVG_WIDTH=0
    SDCL_TOTAL_OVERHEAD=0
    SDCL_LTC_OVERHEAD=0
    SDCL_CPC_OVERHEAD=0
    SDCL_CCES_OVERHEAD=0

	SDCL_PP_OVERHEAD=0
	SDCL_SSEO_OVERHEAD=0
	SDCL_SSOO_OVERHEAD=0
	SATISFIABILITY=(`grep "^s " ${LOG_FILE}`); SATISFIABILITY=${SATISFIABILITY[1]}

	# Normalize reported satisfiability values
	if [[ ${SATISFIABILITY} != ${GLOBAL_SAT} && ${SATISFIABILITY} != ${GLOBAL_UNSAT} ]]; then
		SATISFIABILITY=${GLOBAL_INDET}
	fi

	echo "${SOLVER_NAME},${PROBLEM},${RESTARTS},${CONFLICTS},${DECISIONS},${PROPAGATIONS},${CONF_LITS},${MEM_USED},${CPU_TIME},${SDCL_LEARNTS},${SDCL_CHILDREN_SPAWNED},${SDCL_AVG_WIDTH},${SDCL_TOTAL_OVERHEAD},${SDCL_LTC_OVERHEAD},${SDCL_CPC_OVERHEAD},${SDCL_CCES_OVERHEAD},${SDCL_PP_OVERHEAD},${SDCL_SSEO_OVERHEAD},${SDCL_SSOO_OVERHEAD},${SATISFIABILITY}"
}

# Parse kissat log files
parse_kissat() {
	PROBLEM=$1
	LOG_FILE=$2

	# Parse solver results
	RESTARTS=(`grep "c restarts:" ${LOG_FILE}`); RESTARTS=${RESTARTS[2]}
	CONFLICTS=(`grep "c conflicts:" ${LOG_FILE}`); CONFLICTS=${CONFLICTS[2]}
	DECISIONS=(`grep "c decisions:" ${LOG_FILE}`); DECISIONS=${DECISIONS[2]}
	PROPAGATIONS=(`grep "c propagations:" ${LOG_FILE}`); PROPAGATIONS=${PROPAGATIONS[2]}
	CONF_LITS=(`grep "c literals_learned:" ${LOG_FILE}`); CONF_LITS=${CONF_LITS[2]}
	
	MEM_USED=(`grep "c maximum-resident-set-size:" ${LOG_FILE}`); MEM_USED=${MEM_USED[-2]}
	CPU_TIME=(`grep "c process-time:" ${LOG_FILE}`); CPU_TIME=${CPU_TIME[-2]}
    
    SDCL_LEARNTS=0
    SDCL_CHILDREN_SPAWNED=0
    SDCL_CHILDREN_KILLED=0
    SDCL_CHILDREN_RET_SAT=0
    SDCL_AVG_WIDTH=0
    SDCL_MIN_WIDTH=0
    CDCL_AVG_WIDTH=0
    SDCL_TOTAL_OVERHEAD=0
    SDCL_LTC_OVERHEAD=0
    SDCL_CPC_OVERHEAD=0
    SDCL_CCES_OVERHEAD=0

	SDCL_PP_OVERHEAD=0
	SDCL_SSEO_OVERHEAD=0
	SDCL_SSOO_OVERHEAD=0

	SATISFIABILITY=(`grep "^s " ${LOG_FILE}`); SATISFIABILITY=${SATISFIABILITY[1]}
	
	# Normalize reported satisfiability values
	if [[ ${SATISFIABILITY} != ${GLOBAL_SAT} && ${SATISFIABILITY} != ${GLOBAL_UNSAT} ]]; then
		SATISFIABILITY=${GLOBAL_INDET}
	fi

	echo "${SOLVER_NAME},${PROBLEM},${RESTARTS},${CONFLICTS},${DECISIONS},${PROPAGATIONS},${CONF_LITS},${MEM_USED},${CPU_TIME},${SDCL_LEARNTS},${SDCL_CHILDREN_SPAWNED},${SDCL_AVG_WIDTH},${SDCL_TOTAL_OVERHEAD},${SDCL_LTC_OVERHEAD},${SDCL_CPC_OVERHEAD},${SDCL_CCES_OVERHEAD},${SDCL_PP_OVERHEAD},${SDCL_SSEO_OVERHEAD},${SDCL_SSOO_OVERHEAD},${SATISFIABILITY}"
}

# Parse SDCL log files
parse_SDCL() {
        PROBLEM=$1
        LOG_FILE=$2
		TMP_FILE="${LOG_FILE}.tmp"
		tail -n 25 "${LOG_FILE}" > ${TMP_FILE}

        # Parse solver results
        RESTARTS=(`grep "restarts" ${TMP_FILE}`); RESTARTS=${RESTARTS[2]}
        CONFLICTS=(`grep "conflicts" ${TMP_FILE}`); CONFLICTS=${CONFLICTS[2]}
        DECISIONS=(`grep "decisions" ${TMP_FILE}`); DECISIONS=${DECISIONS[2]}
        PROPAGATIONS=(`grep "propagations" ${TMP_FILE}`); PROPAGATIONS=${PROPAGATIONS[2]}
        CONF_LITS=(`grep "conflict literals" ${TMP_FILE}`); CONF_LITS=${CONF_LITS[3]}

        MEM_USED=(`grep "Memory used" ${TMP_FILE}`); MEM_USED=${MEM_USED[3]}
        CPU_TIME=(`grep "CPU time" ${TMP_FILE}`); CPU_TIME=${CPU_TIME[3]}

        SDCL_LEARNTS=(`grep "SDCL learnts" ${TMP_FILE}`); SDCL_LEARNTS=${SDCL_LEARNTS[4]}
        SDCL_CHILDREN_SPAWNED=(`grep "SDCL children spawned" ${TMP_FILE}`); SDCL_CHILDREN_SPAWNED=${SDCL_CHILDREN_SPAWNED[5]}
        SDCL_CHILDREN_KILLED=(`grep "SDCL children killed" ${TMP_FILE}`); SDCL_CHILDREN_KILLED=${SDCL_CHILDREN_KILLED[5]}
        SDCL_CHILDREN_RET_SAT=(`grep "SDCL children returned SAT" ${TMP_FILE}`); SDCL_CHILDREN_RET_SAT=${SDCL_CHILDREN_RET_SAT[6]}
        SDCL_AVG_WIDTH=(`grep "average SDCL" ${TMP_FILE}`); SDCL_AVG_WIDTH=${SDCL_AVG_WIDTH[4]}
        SDCL_MIN_WIDTH=(`grep "min SDCL" ${TMP_FILE}`); SDCL_MIN_WIDTH=${SDCL_MIN_WIDTH[4]}
        CDCL_AVG_WIDTH=(`grep "average CDCL" ${TMP_FILE}`); CDCL_AVG_WIDTH=${CDCL_AVG_WIDTH[4]}
        SDCL_TOTAL_OVERHEAD=(`grep "total overhead" ${TMP_FILE}`); SDCL_TOTAL_OVERHEAD=${SDCL_TOTAL_OVERHEAD[3]}
        SDCL_LTC_OVERHEAD=(`grep "listen to children" ${TMP_FILE}`); SDCL_LTC_OVERHEAD=${SDCL_LTC_OVERHEAD[5]}
        SDCL_CPC_OVERHEAD=(`grep "preclude clause" ${TMP_FILE}`); SDCL_CPC_OVERHEAD=${SDCL_CPC_OVERHEAD[5]}
        SDCL_CCES_OVERHEAD=(`grep "exist/subsumed" ${TMP_FILE}`); SDCL_CCES_OVERHEAD=${SDCL_CCES_OVERHEAD[5]}

		SDCL_PP_OVERHEAD=(`grep "compute pruning predicate overhead" ${TMP_FILE}`); SDCL_PP_OVERHEAD=${SDCL_PP_OVERHEAD[5]}
		SDCL_SSEO_OVERHEAD=(`grep "subsolver setup overhead" ${TMP_FILE}`); SDCL_SSEO_OVERHEAD=${SDCL_SSEO_OVERHEAD[4]}
		SDCL_SSOO_OVERHEAD=(`grep "subsolver solve overhead" ${TMP_FILE}`); SDCL_SSOO_OVERHEAD=${SDCL_SSOO_OVERHEAD[4]}

        SATISFIABILITY=`tail -n 1 ${TMP_FILE}`

        # Normalize reported satisfiability values
        if [[ ${SATISFIABILITY} != ${GLOBAL_SAT} && ${SATISFIABILITY} != ${GLOBAL_UNSAT} ]]; then
                SATISFIABILITY=${GLOBAL_INDET}
        fi

        echo "${SOLVER_NAME},${PROBLEM},${RESTARTS},${CONFLICTS},${DECISIONS},${PROPAGATIONS},${CONF_LITS},${MEM_USED},${CPU_TIME},${SDCL_LEARNTS},${SDCL_CHILDREN_SPAWNED},${SDCL_AVG_WIDTH},${SDCL_TOTAL_OVERHEAD},${SDCL_LTC_OVERHEAD},${SDCL_CPC_OVERHEAD},${SDCL_CCES_OVERHEAD},${SDCL_PP_OVERHEAD},${SDCL_SSEO_OVERHEAD},${SDCL_SSOO_OVERHEAD},${SATISFIABILITY}"

		# Clean up
		rm "${TMP_FILE}"
}

# Parse lingeling log files
parse_lingeling() {
        PROBLEM=$1
        LOG_FILE=$2

        # Parse solver results
        CPU_TIME=(`grep "seconds," ${LOG_FILE}`); CPU_TIME=${CPU_TIME[1]}
		if [ -z "${CPU_TIME}" ]; then
			CPU_TIME=5000
		fi
		echo "${SOLVER_NAME},${PROBLEM},${CPU_TIME}"
}

# Select parse function
if [[ ${SOLVER_NAME} == maplesat ]]; then
	echo "SOLVER_NAME 0,PROBLEM 1,RESTARTS 2,CONFLICTS 3,DECISIONS 4,PROPAGATIONS 5,CONF_LITS 6,EXT_VARS 7,EXT_DECISIONS 8,CONF_EXT_CLAUSES 9,LEARNT_EXT_CLAUSES 10,LEARNT_LBD 11,MEM_USED 12,CPU_TIME 13,ER0_TIME 14,ER1_TIME 15,ER2_TIME 16,ER3_TIME 17,ER4_TIME 18,SATISFIABILITY 19"
	PARSE_FUNCTION="parse_maplesat"
elif [[ ${SOLVER_NAME} == xmaplesat* ]]; then
	echo "SOLVER_NAME 0,PROBLEM 1,RESTARTS 2,CONFLICTS 3,DECISIONS 4,PROPAGATIONS 5,CONF_LITS 6,EXT_VARS 7,EXT_DECISIONS 8,CONF_EXT_CLAUSES 9,LEARNT_EXT_CLAUSES 10,LEARNT_LBD 11,MEM_USED 12,CPU_TIME 13,ER0_TIME 14,ER1_TIME 15,ER2_TIME 16,ER3_TIME 17,ER4_TIME 18,SATISFIABILITY 19"
	PARSE_FUNCTION="parse_xmaplesat"
elif [[ ${SOLVER_NAME} == maplelcm ]]; then
	echo "SOLVER_NAME 0,PROBLEM 1,RESTARTS 2,CONFLICTS 3,DECISIONS 4,PROPAGATIONS 5,CONF_LITS 6,EXT_VARS 7,EXT_DECISIONS 8,CONF_EXT_CLAUSES 9,LEARNT_EXT_CLAUSES 10,LEARNT_LBD 11,MEM_USED 12,CPU_TIME 13,ER0_TIME 14,ER1_TIME 15,ER2_TIME 16,ER3_TIME 17,ER4_TIME 18,SATISFIABILITY 19"
	PARSE_FUNCTION="parse_maplelcm"
elif [[ ${SOLVER_NAME} == kissat ]]; then
	echo "SOLVER_NAME 0,PROBLEM 1,RESTARTS 2,CONFLICTS 3,DECISIONS 4,PROPAGATIONS 5,CONF_LITS 6,EXT_VARS 7,EXT_DECISIONS 8,CONF_EXT_CLAUSES 9,LEARNT_EXT_CLAUSES 10,LEARNT_LBD 11,MEM_USED 12,CPU_TIME 13,ER0_TIME 14,ER1_TIME 15,ER2_TIME 16,ER3_TIME 17,ER4_TIME 18,SATISFIABILITY 19"
	PARSE_FUNCTION="parse_kissat"
elif [[ ${SOLVER_NAME} == maplesdcl* ]]; then
	echo "SOLVER_NAME 0,PROBLEM 1,RESTARTS 2,CONFLICTS 3,DECISIONS 4,PROPAGATIONS 5,CONF_LITS 6,MEM_USED 7,CPU_TIME 8,SDCL_LEARNTS 9,SDCL_CHILDREN_SPAWN 10,SDCL_AVG_WIDTH 11,SDCL_TOTAL_OVERHEAD 12,SDCL_LTC_OVERHEAD 13,SDCL_CPC_OVERHEAD 14,SDCL_CCES_OVERHEAD 15,SDCL_PP_OVERHEAD 16,SDCL_SSEO_OVERHEAD 17,SDCL_SSOO_OVERHEAD 18,SATISFIABILITY 19"
    PARSE_FUNCTION="parse_SDCL"
elif [[ ${SOLVER_NAME} == lingeling ]]; then
	echo "SOLVER_NAME 0,PROBLEM 1,CPU_TIME 2"
    PARSE_FUNCTION="parse_lingeling"
else
	echo "Solver '${SOLVER_NAME}' is unsupported!"
	exit -1
fi

# Parse files

for line in $(sed "${START_INDEX},${END_INDEX}p;d" "${INPUT_FILE}"); do
	PROBLEM="${line}"
	LOG_FILE="${line}.${SOLVER_NAME}.log"
	${PARSE_FUNCTION} "${PROBLEM}" "${LOG_FILE}"
done
